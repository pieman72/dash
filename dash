#!/bin/bash

# Dash basic configuration
[ -z "$DASH_ROOT" ] && DASH_ROOT="$( cd "$( dirname "$0" )" && pwd )"
[ -z "$DASH_INI_PATH" ] && DASH_INI_PATH="~/.dash.ini"
if [ -f "$DASH_INI_PATH" ]; then
	function load_config(){
		RET="$(awk -F "\\\\s*=\\\\s*" "/^$1=/"' {print $2}'\
			"$DASH_INI_PATH")"
		[ -n "$RET" ] && echo $RET || echo $2
	}
else
	function load_config(){ echo $2; }
fi
DBG=$(load_config "DBG" '0')
REFRESH_RATE_SECONDS=$(load_config "REFRESH_RATE_SECONDS" '120')
DISPLAY_ENCODING=$(load_config "DISPLAY_ENCODING" 'ASCII')
DISPLAY_COLOR_PALETTE=$(load_config "DISPLAY_COLOR_PALETTE" '16')
DISPLAY_ESCAPE_SPACE='`'
if [ "$DISPLAY_ENCODING" == "UTF8" ]; then
	DISPLAY_SEPARATOR_V=$(load_config "DISPLAY_SEPARATOR_V" '│')
	DISPLAY_SEPARATOR_H=$(load_config "DISPLAY_SEPARATOR_H" '─')
	DISPLAY_SEPARATOR_C=$(load_config "DISPLAY_SEPARATOR_C" '┼')
	DISPLAY_SEPARATOR_CA=$(load_config "DISPLAY_SEPARATOR_CA" '┴')
else
	DISPLAY_SEPARATOR_V=$(load_config "DISPLAY_SEPARATOR_V" '|')
	DISPLAY_SEPARATOR_H=$(load_config "DISPLAY_SEPARATOR_H" '-')
	DISPLAY_SEPARATOR_C=$(load_config "DISPLAY_SEPARATOR_C" '+')
	DISPLAY_SEPARATOR_CA=$(load_config "DISPLAY_SEPARATOR_CA" '-')
fi
SECTION_MIN_COLS=$(load_config "SECTION_MIN_COLS" '40')
SECTION_MIN_ROWS=$(load_config "SECTION_MIN_ROWS" '3')
STARTED=0

# Output formatting
if [ "$DISPLAY_COLOR_PALETTE" == "256" ]; then
	COLOR_RESET="[0;39;49m"
	COLOR_BOLD="[1m"
	COLOR_ULINE="[4m"
	COLOR_BOLD_OFF="[0m"
	COLOR_ULINE_OFF="[0m"
	COLOR_NORM="[0;39m"
	COLOR_GREN="[38;5;118m"
	COLOR_BLUE="[38;5;26m"
	COLOR_LBLU="[38;5;81m"
	COLOR_RED="[38;5;161m"
	COLOR_PURP="[38;5;135m"
	COLOR_ORNG="[38;5;208m"
	COLOR_YELO="[38;5;227m"
	COLOR_GRAY="[38;5;245m"
	COLOR_WHIT="[38;5;15m"
	COLOR_BG_NORM="[49m"
	COLOR_BG_GREN="[48;5;118m"
	COLOR_BG_BLUE="[48;5;26m"
	COLOR_BG_LBLU="[48;5;81m"
	COLOR_BG_RED="[48;5;161m"
	COLOR_BG_PURP="[48;5;135m"
	COLOR_BG_ORNG="[48;5;208m"
	COLOR_BG_YELO="[48;5;227m"
	COLOR_BG_GRAY="[48;5;245m"
	COLOR_BG_WHIT="[48;5;15m"
elif [ "$DISPLAY_COLOR_PALETTE" == "16" ]; then
	COLOR_RESET="[0;39;49m"
	COLOR_BOLD="[1m"
	COLOR_ULINE="[4m"
	COLOR_BOLD_OFF="[0m"
	COLOR_ULINE_OFF="[0m"
	COLOR_NORM="[0;39m"
	COLOR_GREN="[32m"
	COLOR_BLUE="[1;34m"
	COLOR_LBLU="[1;36m"
	COLOR_RED="[31m"
	COLOR_PURP="[35m"
	COLOR_ORNG="[33m"
	COLOR_YELO="[1;33m"
	COLOR_GRAY="[37m"
	COLOR_WHIT="[1;37m"
	COLOR_BG_NORM="[0;49m"
	COLOR_BG_GREN="[42m"
	COLOR_BG_BLUE="[1;44m"
	COLOR_BG_LBLU="[1;46m"
	COLOR_BG_RED="[41m"
	COLOR_BG_PURP="[45m"
	COLOR_BG_ORNG="[43m"
	COLOR_BG_YELO="[1;43m"
	COLOR_BG_GRAY="[47m"
	COLOR_BG_WHIT="[1;47m"
elif [ "$DISPLAY_COLOR_PALETTE" == "8" ]; then
	COLOR_RESET="[0;39;49m"
	COLOR_BOLD=""
	COLOR_ULINE=""
	COLOR_BOLD_OFF=""
	COLOR_ULINE_OFF=""
	COLOR_NORM="[39m"
	COLOR_GREN="[32m"
	COLOR_BLUE="[34m"
	COLOR_LBLU="[34m"
	COLOR_RED="[31m"
	COLOR_PURP="[35m"
	COLOR_ORNG="[33m"
	COLOR_YELO="[33m"
	COLOR_GRAY="[37m"
	COLOR_WHIT="[37m"
	COLOR_BG_NORM="[49m"
	COLOR_BG_GREN="[42m"
	COLOR_BG_BLUE="[44m"
	COLOR_BG_LBLU="[44m"
	COLOR_BG_RED="[41m"
	COLOR_BG_PURP="[45m"
	COLOR_BG_ORNG="[43m"
	COLOR_BG_YELO="[43m"
	COLOR_BG_GRAY="[47m"
	COLOR_BG_WHIT="[47m"
fi
function msg(){
	echo -e "$COLOR_RESET$COLOR_GRAY[Dash]$COLOR_NORM $1\n"
}
function error(){
	echo -e "$COLOR_RESET$COLOR_GRAY[Dash] $COLOR_RED""Error:$COLOR_NORM $1\n"\
		>&2
	read -p "$(echo -e '[Press ENTER to exit]\n\b')" TMP
	if [[ -z "$2" ]]; then exit 1; fi; exit "$2"
}
function center(){
	LEN=$(wc -m <<< "$1")
	printf "%*s%s\n" $(( ($2 - $LEN + 1) / 2)) " " "$1"
}
declare -A LARGE_READ_OUT
LARGE_READ_OUT["0",0]=" XXX "
LARGE_READ_OUT["0",1]="X   X"
LARGE_READ_OUT["0",2]="X   X"
LARGE_READ_OUT["0",3]="X   X"
LARGE_READ_OUT["0",4]=" XXX "
LARGE_READ_OUT["1",0]="  X  "
LARGE_READ_OUT["1",1]=" XX  "
LARGE_READ_OUT["1",2]="  X  "
LARGE_READ_OUT["1",3]="  X  "
LARGE_READ_OUT["1",4]=" XXX "
LARGE_READ_OUT["2",0]=" XXX "
LARGE_READ_OUT["2",1]="X   X"
LARGE_READ_OUT["2",2]="  XX "
LARGE_READ_OUT["2",3]=" X   "
LARGE_READ_OUT["2",4]="XXXXX"
LARGE_READ_OUT["3",0]="XXXX "
LARGE_READ_OUT["3",1]="    X"
LARGE_READ_OUT["3",2]=" XXX "
LARGE_READ_OUT["3",3]="    X"
LARGE_READ_OUT["3",4]="XXXX "
LARGE_READ_OUT["4",0]="   X "
LARGE_READ_OUT["4",1]="  XX "
LARGE_READ_OUT["4",2]=" X X "
LARGE_READ_OUT["4",3]="XXXXX"
LARGE_READ_OUT["4",4]="   X "
LARGE_READ_OUT["5",0]="XXXXX"
LARGE_READ_OUT["5",1]="X    "
LARGE_READ_OUT["5",2]="XXXX "
LARGE_READ_OUT["5",3]="    X"
LARGE_READ_OUT["5",4]="XXXX "
LARGE_READ_OUT["6",0]=" XXXX"
LARGE_READ_OUT["6",1]="X    "
LARGE_READ_OUT["6",2]="XXXX "
LARGE_READ_OUT["6",3]="X   X"
LARGE_READ_OUT["6",4]=" XXX "
LARGE_READ_OUT["7",0]="XXXXX"
LARGE_READ_OUT["7",1]="    X"
LARGE_READ_OUT["7",2]="   X "
LARGE_READ_OUT["7",3]="  X  "
LARGE_READ_OUT["7",4]="  X  "
LARGE_READ_OUT["8",0]=" XXX "
LARGE_READ_OUT["8",1]="X   X"
LARGE_READ_OUT["8",2]=" XXX "
LARGE_READ_OUT["8",3]="X   X"
LARGE_READ_OUT["8",4]=" XXX "
LARGE_READ_OUT["9",0]=" XXX "
LARGE_READ_OUT["9",1]="X   X"
LARGE_READ_OUT["9",2]="XXXXX"
LARGE_READ_OUT["9",3]="    X"
LARGE_READ_OUT["9",4]="XXXX "
LARGE_READ_OUT["-",0]="     "
LARGE_READ_OUT["-",1]="     "
LARGE_READ_OUT["-",2]=" XXXX"
LARGE_READ_OUT["-",3]="     "
LARGE_READ_OUT["-",4]="     "
LARGE_READ_OUT["F",0]="XXXXX"
LARGE_READ_OUT["F",1]="X    "
LARGE_READ_OUT["F",2]="XXXX "
LARGE_READ_OUT["F",3]="X    "
LARGE_READ_OUT["F",4]="X    "
LARGE_READ_OUT["C",0]=" XXX "
LARGE_READ_OUT["C",1]="X   X"
LARGE_READ_OUT["C",2]="X    "
LARGE_READ_OUT["C",3]="X   X"
LARGE_READ_OUT["C",4]=" XXX "
LARGE_READ_OUT[".",0]="     "
LARGE_READ_OUT[".",1]="     "
LARGE_READ_OUT[".",2]="     "
LARGE_READ_OUT[".",3]="     "
LARGE_READ_OUT[".",4]="  X  "
LARGE_READ_OUT["°",0]=" XXX "
LARGE_READ_OUT["°",1]=" X X "
LARGE_READ_OUT["°",2]=" XXX "
LARGE_READ_OUT["°",3]="     "
LARGE_READ_OUT["°",4]="     "
LARGE_READ_OUT["'",0]=" XXX "
LARGE_READ_OUT["'",1]=" X X "
LARGE_READ_OUT["'",2]=" XXX "
LARGE_READ_OUT["'",3]="     "
LARGE_READ_OUT["'",4]="     "

# Support functions
function GCD(){
	if [ $# -ne 2 ]; then error "GCD() got incorrect arg count"; fi
	if [ $1 -le 1 ]; then error "GCD() got too small argument"; fi
	if [ $2 -le 1 ]; then error "GCD() got too small argument"; fi
	NUM=$1
	DEN=$2
	REM=$((NUM%DEN))
	until [ "$REM" -eq 0 ]; do
		NUM=$DEN
		DEN=$REM
		REM=$((NUM%DEN))
	done
	echo $DEN
}
function randomize(){
	LEN=$(( (${#1}>10?10:${#1}) - 1 ))
	RET=""
	ORDER=""
	while [ "${#ORDER}" -lt "$2" ]; do
		ORDER=$ORDER$(grep -o "[0-$LEN]"<<<$(date +%s%3N|md5sum)|paste -sd "")
	done
	for i in `seq 0 $(($2 - 1))`; do
		POS=${ORDER:$i:1}
		RET="$RET"${1:$POS:1}
	done
	echo $RET
}
function handleWindowChange(){
	render_sections
}
function handleInterrupt(){
	exit 0
}
function handleExit(){
	stty echo
	tput rmcup
}

# Handle CLI args
SHOW_HELP=0
if [ "$#" -lt 1 ]; then SHOW_HELP=1; fi
SECT_LIST=''
SHOW_CALENDAR=0
SHOW_EMAIL=0
SHOW_MATRIX=0
SHOW_NEWS=0
SHOW_SNAKE=0
SHOW_WEATHER=0
SHOW_STATS=0
while getopt -Q -q -o 'HCEMNSWYd:' -n 'dash' -- $@; do
	case "$1" in
		-H) SHOW_HELP=1;     SECT_LIST+='H'; shift ;;
		-C) SHOW_CALENDAR=1; SECT_LIST+='C'; shift ;;
		-E) SHOW_EMAIL=1;    SECT_LIST+='E'; shift ;;
		-N) SHOW_MATRIX=1;   SECT_LIST+='M'; shift ;;
		-N) SHOW_NEWS=1;     SECT_LIST+='N'; shift ;;
		-S) SHOW_SNAKE=1;    SECT_LIST+='S'; shift ;;
		-W) SHOW_WEATHER=1;  SECT_LIST+='W'; shift ;;
		-Y) SHOW_STATS=1;    SECT_LIST+='Y'; shift ;;
		-d) DBG=1; shift ;;
		""|--) shift; break ;;
		*) error "Unrecognized option $1" ;;
	esac
done
if [[ -n "$1" ]]; then error "Unrecognized option $1"; fi
SECT_LIST=`echo $SECT_LIST | grep -o .`
SECTS=$(wc -l <<< "$SECT_LIST")

# Only in the case of the help menu being requested, print help and exit
if [ "$SHOW_HELP" = 1 ]; then
	echo -e "[1mSYNOPSIS[0m\n\
\t[1mdash[0m [[4moptions[0m]\n\n\
[1mOPTIONS[0m\n\
\t[1m-C[0m\n\
\t\tInclude a calendar readout in the output (you will be prompted for \
credentials).\n\n\
\t[1m-d[0m\n\
\t\tPrint debugging information (overrides value in your dashrc). No sections \
will be shown.\n\n\
\t[1m-E[0m\n\
\t\tInclude an email digest in the output (you will be prompted for \
credentials).\n\n\
\t[1m-H[0m\n\
\t\tOuput these instructions, and exit.\n\n\
\t[1m-M[0m\n\
\t\tInclude The Matrix!\n\n\
\t[1m-N[0m\n\
\t\tInclude a news digest in the output.\n\n\
\t[1m-S[0m\n\
\t\tInclude snake!\n\n\
\t[1m-W[0m\n\
\t\tInclude a weather forecast in the output.\n\n\
\t[1m-Y[0m\n\
\t\tInclude system stats in the output (output may be reduced if run without \
privileges).\n"
	exit
fi

# Additional configuration for individual sections
if [ "$SHOW_CALENDAR" = 1 ]; then
	CALENDAR_SECONDS_PER_POLL=$(load_config "CALENDAR_SECONDS_PER_POLL" "600")
fi
if [ "$SHOW_EMAIL" = 1 ]; then
	EMAIL_SECONDS_PER_POLL=$(load_config "EMAIL_SECONDS_PER_POLL" "300")
	EMAIL_SOURCE=$(load_config "EMAIL_SOURCE" "Gmail")
	read -p "Please enter the username for your $EMAIL_SOURCE account: "\
		EMAIL_USER
	read -p "Password: " -s EMAIL_PASS
fi
if [ "$SHOW_MATRIX" = 1 ]; then
	MATRIX_SECONDS_PER_POLL=$(load_config "MATRIX_SECONDS_PER_POLL" "0.5")
fi
if [ "$SHOW_NEWS" = 1 ]; then
	NEWS_SECONDS_PER_POLL=$(load_config "NEWS_SECONDS_PER_POLL" "1800")
fi
if [ "$SHOW_SNAKE" = 1 ]; then
	SNAKE_SECONDS_PER_POLL=$(load_config "SNAKE_SECONDS_PER_POLL" "10")
fi
if [ "$SHOW_WEATHER" = 1 ]; then
	# Get INI values
	WEATHER_SECONDS_PER_POLL=$(load_config "WEATHER_SECONDS_PER_POLL" "600")
	WEATHER_NOAA_STATION_CODE=$(load_config "WEATHER_NOAA_STATION_CODE" "KNYC")
	WEATHER_TEMPERATURE_UNITS=$(load_config "WEATHER_TEMPERATURE_UNITS" "F")
	if [ "$WEATHER_TEMPERATURE_UNITS" == 'F' ]; then
		WEATHER_TEMPERATURE_OFFSET=0
	else
		WEATHER_TEMPERATURE_OFFSET=1
		WEATHER_TEMPERATURE_UNITS='C'
	fi
	if [ "$DISPLAY_ENCODING" == 'UTF8' ]; then
		WEATHER_DEGREE_SYMBOL="°"
	else
		WEATHER_DEGREE_SYMBOL="'"
	fi
fi
if [ "$SHOW_STATS" = 1 ]; then
	STATS_SECONDS_PER_POLL=$(load_config "STATS_SECONDS_PER_POLL" "60")
fi

# Save the old screen, block input echo, and set signal traps
tput smcup
stty -echo
trap handleWindowChange WINCH
trap handleInterrupt INT
trap handleExit EXIT

# Handle the actual rendering of dash sections
function render_sections(){
	# Get loop params from shell
	NEW_DATE=`date +%s`
	COLS=`tput cols`
	ROWS=`tput lines`
	RENDER_SECT_LIST=$SECT_LIST

	# Make sure there is enough space for anything
	if [ "$COLS" -lt "$SECTION_MIN_COLS" ] ||\
			[ "$ROWS" -lt "$SECTION_MIN_ROWS" ]; then
		clear
		msg "Screen too small!"
		read -t $REFRESH_RATE_SECONDS TMP
		continue
	fi

	# Compute optimal size per section
	TEMP_WIDTH=SECTION_MIN_COLS
	while [ "$((SECTS * (TEMP_WIDTH+1) - 1))" -lt "$COLS" ]; do
		((TEMP_WIDTH+=10))
	done
	TEMP_WIDTH=$(( TEMP_WIDTH>COLS ? COLS : TEMP_WIDTH ))
	SECTS_X=$(( (COLS+1)/(TEMP_WIDTH+1) ))
	SECTS_Y=$(( SECTS/SECTS_X + (SECTS%SECTS_X ? 1 : 0) ))
	while [ "$(( SECTS_Y*COLS*5 ))" -lt "$(( SECTS_X*ROWS*12 ))" ]; do
		((--SECTS_X))
		SECTS_Y=$(( SECTS/SECTS_X + (SECTS%SECTS_X ? 1 : 0) ))
	done
	BLANK_SECTS=$(( SECTS_X*SECTS_Y - SECTS ))
	if [ "$BLANK_SECTS" -gt "0" ]; then
		SECTS=$(( SECTS + BLANK_SECTS ))
		if [ "$BLANK_SECTS" -eq "1" ]; then
			RENDER_SECT_LIST=$(echo $RENDER_SECT_LIST; echo "_")
		else
			RENDER_SECT_LIST=$(echo $RENDER_SECT_LIST; echo "_";
				printf "\n_%.0s" $(seq 2 $BLANK_SECTS))
		fi
	fi
	BASE_COLS=$(( COLS/SECTS_X ))
	BASE_ROWS=$(( ROWS/SECTS_Y ))
	EXTRA_X=$(( COLS-SECTS_X*BASE_COLS ))
	EXTRA_Y=$(( ROWS-SECTS_Y*BASE_ROWS ))
	SECTS_PROCESSED=0
	ROWS_PROCESSED=0
	COLS_PROCESSED=0

	# Make sure there is enough space for optimal layout
	if [ "$COLS" -lt "$(( (SECTION_MIN_COLS+1)*SECTS_X-1 ))" ]\
			|| [ "$ROWS" -lt "$(( (SECTION_MIN_ROWS+1)*SECTS_Y-1 ))" ]; then
		clear
		msg "Not enough space for all tiles"
		read -t $REFRESH_RATE_SECONDS TMP
		continue
	fi

	# Print debugging info about all section metrics
	if [ "$DBG" = 1 ]; then
		msg "Sections: $SECTS"
		msg "Layout: $SECTS_X x $SECTS_Y"
		msg "Size per section: $BASE_COLS x $BASE_ROWS"
		msg "Extra: $EXTRA_X, $EXTRA_Y"
	fi

	# Inner loop to handle each particular section
	PREV_SECT=""
	for CUR_SECT in $RENDER_SECT_LIST; do
		# Figure out the specific size of this section
		CUR_X=$((SECTS_PROCESSED%SECTS_X))
		CUR_Y=$((SECTS_PROCESSED/SECTS_X))
		BORDER_LEFT=$((CUR_X>0 ? 1 : 0))
		BORDER_TOP=$((CUR_Y>0 ? 1 : 0))
		CUR_COLS=$((BASE_COLS+(CUR_X+EXTRA_X>=SECTS_X ? 1 : 0)-BORDER_LEFT))
		CUR_ROWS=$((BASE_ROWS+(CUR_Y+EXTRA_Y>=SECTS_Y ? 1 : 0)-BORDER_TOP))
		NEW_SIZE=$CUR_COLS"x"$CUR_ROWS

		# Print debugging info about specific section
		if [ "$DBG" = 1 ]; then
			msg "Section '$CUR_SECT'  Size $NEW_SIZE"
		fi

		# Initialize freshness and printing vars
		DATA_FRESH=0
		SIZE_FRESH=0
		DATE=0
		DATA=''
		SIZE='0x0'
		DRAW=()
		NEW_DATA=''
		NEW_DRAW=()

		# Get seconds per poll for this section
		if [ "$CUR_SECT" == '_' ]; then
			SECONDS_PER_POLL=100000
		elif [ "$CUR_SECT" == 'C' ]; then
			SECONDS_PER_POLL=$CALENDAR_SECONDS_PER_POLL
		elif [ "$CUR_SECT" == 'E' ]; then
			SECONDS_PER_POLL=$EMAIL_SECONDS_PER_POLL
		elif [ "$CUR_SECT" == 'M' ]; then
			SECONDS_PER_POLL=$MATRIX_SECONDS_PER_POLL
		elif [ "$CUR_SECT" == 'N' ]; then
			SECONDS_PER_POLL=$NEWS_SECONDS_PER_POLL
		elif [ "$CUR_SECT" == 'S' ]; then
			SECONDS_PER_POLL=$SNAKE_SECONDS_PER_POLL
		elif [ "$CUR_SECT" == 'W' ]; then
			SECONDS_PER_POLL=$WEATHER_SECONDS_PER_POLL
		elif [ "$CUR_SECT" == 'Y' ]; then
			SECONDS_PER_POLL=$STATS_SECONDS_PER_POLL
		fi

		# Check any previous data
		if [ -f "$DASH_ROOT/$CUR_SECT"".dash" ]; then
			# See if data is still fresh
			OLD_DATE=$(head -n 1 "$DASH_ROOT/$CUR_SECT"".dash" | tail -n 1)
			OLD_DATA=$(head -n 2 "$DASH_ROOT/$CUR_SECT"".dash" | tail -n 1)
			if [ $OLD_DATE -ge $((NEW_DATE-SECONDS_PER_POLL)) ];
				then
				DATA_FRESH=1

				# See if the display size is still correct
				OLD_SIZE=$(head -n 3 "$DASH_ROOT/$CUR_SECT"".dash" | tail -n 1)
				OLD_DRAW=$(tail -n +4 "$DASH_ROOT/$CUR_SECT"".dash")
				if [ "$OLD_SIZE" == "$NEW_SIZE" ] && [ "$STARTED" == 1 ] ; then
					SIZE_FRESH=1
				fi
			fi
		fi

		# --- Blank -----------------------------------------
		if [ "$CUR_SECT" == '_' ]; then
			# Create an empty array of rows
			NEW_DRAW=($DISPLAY_ESCAPE_SPACE$(printf\
				" $DISPLAY_ESCAPE_SPACE%.0s" $(seq 2 $CUR_ROWS)))
			for i in `seq 0 $((CUR_ROWS-1))`; do NEW_DRAW[$i]=" "; done
		fi

		# --- Calendar --------------------------------------
		if [ "$CUR_SECT" == 'C' ]; then
			echo -n ""
		fi

		# --- Email -----------------------------------------
		if [ "$CUR_SECT" == 'E' ]; then
			# If the data is old, download new data, otherwise use the old data
			if [ "$DATA_FRESH" = 0 ]; then
				if [ "$EMAIL_SOURCE" == "Gmail" ]; then
					URL="https://mail.google.com/mail/feed/atom"
					FEED=$(curl -u "$EMAIL_USER:$EMAIL_PASS" --silent "$URL")
					MAILCOUNT=$(grep -oPm1 "(?<=<fullcount>)[^<]*"\
							<<< "$FEED")
					NEW_DATA=$MAILCOUNT
					OLDIFS=$IFS
					IFS=$'\n'
					FEED=($(grep -oPm1 "<entry>.*?</entry>" <<< "$FEED"))
					for i in `seq 0 $((MAILCOUNT - 1))`; do
						ENTRY=${FEED[$i]}
						D_senderName=$(grep -oPm1 "(?<=<name>)[^<]*"\
							<<< "$ENTRY")
						D_senderEmail=$(grep -oPm1 "(?<=<email>)[^<]*"\
							<<< "$ENTRY")
						D_subject=$(grep -oPm1 "(?<=<title>)[^<]*"\
							<<< "$ENTRY")
						D_date=$(grep -oPm1 "(?<=<modified>)[^<]*"\
							<<< "$ENTRY")
						D_content=$(grep -oPm1 "(?<=<summary>)[^<]*"\
							<<< "$ENTRY")
						NEW_DATA=$NEW_DATA$(echo -e "\u07")
						NEW_DATA=$NEW_DATA$D_senderName$(echo -e "\u06")
						NEW_DATA=$NEW_DATA$D_senderEmail$(echo -e "\u06")
						NEW_DATA=$NEW_DATA$D_date$(echo -e "\u06")
						NEW_DATA=$NEW_DATA$D_subject$(echo -e "\u06")
						NEW_DATA=$NEW_DATA$D_content
						FIRST_ENTRY=0;
					done
					IFS=$OLDIFS
					DATA=$NEW_DATA
				else
					DATA=$OLD_DATA
				fi
			else
				DATA=$OLD_DATA
			fi

			# If the drawing is old, redo it
			if [ "$SIZE_FRESH" = 0 ]; then
				# Create an empty array of rows
				NEW_DRAW=($DISPLAY_ESCAPE_SPACE$(printf\
					" $DISPLAY_ESCAPE_SPACE%.0s" $(seq 2 $CUR_ROWS)))
				for i in `seq 0 $((CUR_ROWS-1))`; do NEW_DRAW[$i]=" "; done

				# Expand the data into an array, handling string escapes
				OLDIFS=$IFS
				IFS=$(echo -e "\u07")
				DATA_ARRAY=($DATA)
				IFS=$OLDIFS

				# Loop through each email message
				for i in `seq 0 ${DATA_ARRAY[0]}`; do
					# Get the email message pieces
					OLDIFS=$IFS
					IFS=$(echo -e "\u06")
					DATA_PIECES=(${DATA_ARRAY[$i]})
					IFS=$OLDIFS

					# Smallest heights (3-7): just show most relevant info
					if [ "$CUR_ROWS" -lt 8 ]; then
						# For the heading
						if [ "$i" == "0" ]; then
							# Row 0 shows the message count
							NEW_DRAW[0]="${DATA_ARRAY[$i]} New Messages"
						# For each message
						else
							# Row 1... Shows sender name and subject
							NEW_DRAW[$i]="$COLOR_BOLD${DATA_PIECES[0]}\
$COLOR_BOLD_OFF - ${DATA_PIECES[3]}"
						fi

					# Medium heights (8-19): add some formatting
					elif [ "$CUR_ROWS" -lt 20 ]; then
						# For the heading
						if [ "$i" == "0" ]; then
							# Row 0 has a heading
							NEW_DRAW[0]=" $COLOR_GRAY["$COLOR_ULINE"Email\
$COLOR_ULINE_OFF]$COLOR_NORM"

							# Row 1 shows the message count
							NEW_DRAW[1]="${DATA_ARRAY[$i]} New Messages"
						# For each message
						else
							# Row 2... shows the sender's name and date
							NEW_DRAW[$((i*3))]="From: $COLOR_BOLD\
${DATA_PIECES[0]}$COLOR_BOLD_OFF  -  ${DATA_PIECES[2]}"

							# Row 3... shows the subject and message content
							NEW_DRAW[$((i*3+1))]="$COLOR_ULINE\
${DATA_PIECES[3]}$COLOR_ULINE_OFF - ${DATA_PIECES[4]}"
						fi


					# Largest heights (20+): the full Monty!
					else
						# For the heading
						if [ "$i" == "0" ]; then
							# Rows 0-1 have a heading
							if [ "$DISPLAY_ENCODING" == "UTF8" ]; then
								NEW_DRAW[0]="$COLOR_GRAY Email $COLOR_NORM│"
								NEW_DRAW[1]="───────┘"
							else
								NEW_DRAW[0]="$COLOR_GRAY Email $COLOR_NORM|"
								NEW_DRAW[1]="-------+"
							fi

							# Row 2 shows the message count
							NEW_DRAW[2]="${DATA_ARRAY[$i]} New Messages"
						# For each message
						else
							# Row 3... shows the sender's info and date
							NEW_DRAW[$((i*4))]="From: $COLOR_BOLD\
${DATA_PIECES[0]}$COLOR_BOLD_OFF  <${DATA_PIECES[1]}>  -  ${DATA_PIECES[2]}"

							# Row 4... shows the subject
							NEW_DRAW[$((i*4+1))]="Subject: $COLOR_ULINE\
${DATA_PIECES[3]}$COLOR_ULINE_OFF"

							# Row 5... shows the message content
							NEW_DRAW[$((i*4+2))]="${DATA_PIECES[4]}"
						fi
					fi
				done
			fi
		fi

		# --- Matrix ----------------------------------------
		if [ "$CUR_SECT" == 'M' ]; then
			echo -n ""
		fi

		# --- News ------------------------------------------
		if [ "$CUR_SECT" == 'N' ]; then
			echo -n ""
		fi

		# --- Snake -----------------------------------------
		if [ "$CUR_SECT" == 'S' ]; then
			echo -n ""
		fi

		# --- Weather ---------------------------------------
		if [ "$CUR_SECT" == 'W' ]; then
			# If the data is old, download new data, otherwise use the old data
			if [ "$DATA_FRESH" = 0 ]; then
				URL="http://www.weather.gov/xml/current_obs/"
				DOWNLOAD=$(wget -q -O- "$URL$WEATHER_NOAA_STATION_CODE"".xml")
				D_cred=$(grep -oPm1 "(?<=<credit_URL>)[^<]*"\
					<<< "$DOWNLOAD")
				D_loc=$(grep -oPm1 "(?<=<location>)[^<]*"\
					<<< "$DOWNLOAD")
				D_lat=$(grep -oPm1 "(?<=<latitude>)[^<]*"\
					<<< "$DOWNLOAD")
				D_lon=$(grep -oPm1 "(?<=<longitude>)[^<]*"\
					<<< "$DOWNLOAD")
				D_time=$(grep -oPm1 "(?<=<observation_time_rfc822>)[^<]*"\
					<<< "$DOWNLOAD")
				D_weather=$(grep -oPm1 "(?<=<weather>)[^<]*"\
					<<< "$DOWNLOAD")
				D_temp_f=$(grep -oPm1 "(?<=<temp_f>)[^<]*"\
					<<< "$DOWNLOAD"); D_temp_f=$(sed "s/\..//" <<< "$D_temp_f")
				D_temp_c=$(grep -oPm1 "(?<=<temp_c>)[^<]*"\
					<<< "$DOWNLOAD"); D_temp_c=$(sed "s/\..//" <<< "$D_temp_c")
				D_hu=$(grep -oPm1 "(?<=<relative_humidity>)[^<]*"\
					<<< "$DOWNLOAD")
				D_w_dir=$(grep -oPm1 "(?<=<wind_dir>)[^<]*"\
					<<< "$DOWNLOAD")
				D_w_mph=$(grep -oPm1 "(?<=<wind_mph>)[^<]*"\
					<<< "$DOWNLOAD")
				D_chil_f=$(grep -oPm1 "(?<=<windchill_f>)[^<]*"\
					<<< "$DOWNLOAD")
				D_chil_c=$(grep -oPm1 "(?<=<windchill_c>)[^<]*"\
					<<< "$DOWNLOAD")
				D_vis=$(grep -oPm1 "(?<=<visibility_mi>)[^<]*"\
					<<< "$DOWNLOAD")
				if [ -z "$D_chil_f" ]; then D_chil_f='-'; fi
				if [ -z "$D_chil_c" ]; then D_chil_c='-'; fi
				if [ -z "$D_w_dir" ]; then D_w_dir='-'; fi
				if [ -z "$D_w_mph" ]; then D_w_mph='-'; fi
				NEW_DATA="$D_weather;$D_temp_f;$D_temp_c;$D_chil_f;$D_chil_c;\
$D_hu;$D_time;$D_cred;$D_w_dir;$D_w_mph;$D_vis;$D_loc;$D_lat;$D_lon\n"
				DATA=$NEW_DATA
			else
				DATA=$OLD_DATA
			fi

			# If the drawing is old, redo it
			if [ "$SIZE_FRESH" = 0 ]; then
				# Expand the data into an array, handling string escapes
				DATA_ESCAPED=${DATA// /$DISPLAY_ESCAPE_SPACE}
				DATA_ARRAY=(${DATA_ESCAPED//;/' '})
				for i in `seq 0 $((${#DATA_ARRAY[@]}-1))`; do
					DATA_ARRAY[$i]=${DATA_ARRAY[$i]//$DISPLAY_ESCAPE_SPACE/ }
				done

				# Create an empty array of rows
				NEW_DRAW=($DISPLAY_ESCAPE_SPACE$(printf\
					" $DISPLAY_ESCAPE_SPACE%.0s" $(seq 2 $CUR_ROWS)))
				for i in `seq 0 $((CUR_ROWS-1))`; do NEW_DRAW[$i]=""; done

				# Smallest heights (3-7): just show most relevant info
				if [ "$CUR_ROWS" -lt 8 ]; then
					# Row 0 shows the weather status
					NEW_DRAW[0]=$(center "${DATA_ARRAY[0]}" $CUR_COLS)

					# Row 1 shows the temperature
					NEW_DRAW[1]=${DATA_ARRAY[$((1+WEATHER_TEMPERATURE_OFFSET\
						))]}$WEATHER_DEGREE_SYMBOL$WEATHER_TEMPERATURE_UNITS
					if [ "${DATA_ARRAY[$((3+WEATHER_TEMPERATURE_OFFSET))]}" \
						!= '-' ]; then
						NEW_DRAW[1]=${NEW_DRAW[1]}"  (feels like "\
${DATA_ARRAY[3]}$WEATHER_DEGREE_SYMBOL")"
					fi
					NEW_DRAW[1]=$(center "${NEW_DRAW[1]}" $CUR_COLS)

					# Row 2 shows the humidity
					NEW_DRAW[2]=$(center "Humidity: ${DATA_ARRAY[5]}%"\
						$CUR_COLS)

					# Row 3 shows the wind
					if [ "$CUR_ROWS" -gt 5 ]; then
						NEW_DRAW[3]=$(center "Wind: "${DATA_ARRAY[8]}\
" ${DATA_ARRAY[9]}mph" $CUR_COLS)
					fi

					# Row 4 shows visibility
					if [ "$CUR_ROWS" -gt 6 ]; then
						NEW_DRAW[4]=$(center "Visibility: ${DATA_ARRAY[10]}mi"\
							$CUR_COLS)
					fi

					# Row N-1 shows the update timestamp
					if [ "$CUR_ROWS" -gt 3 ]; then
						NEW_DRAW[$((CUR_ROWS-1))]=$(center "Updated: $(date -d\
							"${DATA_ARRAY[6]}" "+%I:%M%p") | ${DATA_ARRAY[7]}"\
							$CUR_COLS)
					fi

				# Medium heights (8-19): add some formatting
				elif [ "$CUR_ROWS" -lt 20 ]; then
					# Row 0 has a heading
					NEW_DRAW[0]=" $COLOR_GRAY["$COLOR_ULINE"Weather\
$COLOR_ULINE_OFF]$COLOR_NORM"

					# Rows 1-3 are the weather status and its border
					DECORATION_STRING=" "
					DECORATION_COLOR="$COLOR_NORM"
					# Fair
					if [ "${DATA_ARRAY[0]}" == "Fair" ]; then
						DECORATION_STRING="-$DISPLAY_ESCAPE_SPACE"
						DECORATION_COLOR="$COLOR_YELO"
					# A Few Clouds
					elif [ "${DATA_ARRAY[0]}" == "A Few Clouds" ]; then
						if [ "$DISPLAY_ENCODING" == "UTF8" ]; then
							DECORATION_STRING="~☁$DISPLAY_ESCAPE_SPACE\
$DISPLAY_ESCAPE_SPACE$DISPLAY_ESCAPE_SPACE"
						else
							DECORATION_STRING="~3$DISPLAY_ESCAPE_SPACE\
$DISPLAY_ESCAPE_SPACE$DISPLAY_ESCAPE_SPACE"
						fi
						DECORATION_COLOR="$COLOR_YELO"
					# Partly Cloudy
					elif [ "${DATA_ARRAY[0]}" == "Partly Cloudy" ]; then
						if [ "$DISPLAY_ENCODING" == "UTF8" ]; then
							DECORATION_STRING="☁~$DISPLAY_ESCAPE_SPACE\
$DISPLAY_ESCAPE_SPACE"
						else
							DECORATION_STRING="3~$DISPLAY_ESCAPE_SPACE\
$DISPLAY_ESCAPE_SPACE"
						fi
						DECORATION_COLOR="$COLOR_WHIT"
					# Mostly Cloudy
					elif [ "${DATA_ARRAY[0]}" == "Mostly Cloudy" ]; then
						if [ "$DISPLAY_ENCODING" == "UTF8" ]; then
							DECORATION_STRING="☁~$DISPLAY_ESCAPE_SPACE"
						else
							DECORATION_STRING="3~$DISPLAY_ESCAPE_SPACE"
						fi
						DECORATION_COLOR="$COLOR_GRAY"
					# Overcast with Haze
					elif [ "${DATA_ARRAY[0]}" == "Overcast with Haze" ]; then
						if [ "$DISPLAY_ENCODING" == "UTF8" ]; then
							DECORATION_STRING="☁☁ᢆᢆ░3~"
						else
							DECORATION_STRING="333~~"
						fi
						DECORATION_COLOR="$COLOR_GRAY"
					# Overcast
					elif [ "${DATA_ARRAY[0]}" == "Overcast" ]; then
						if [ "$DISPLAY_ENCODING" == "UTF8" ]; then
							DECORATION_STRING="☁☁☁3~"
						else
							DECORATION_STRING="333~~"
						fi
						DECORATION_COLOR="$COLOR_GRAY"
					# Rain
					elif [ "${DATA_ARRAY[0]}" == "Rain" ]; then
						DECORATION_STRING='````'"'''\\\\\|"
						DECORATION_COLOR="$COLOR_BLUE"
					# Light Freezing Rain Fog/Mist
					elif [ "${DATA_ARRAY[0]}" ==\
						"Light Freezing Rain Fog/Mist" ]; then
						if [ "$DISPLAY_ENCODING" == "UTF8" ]; then
							DECORATION_STRING="\`\`\\\\☁~   "
						else
							DECORATION_STRING="\`\`\\\\3~   "
						fi
						DECORATION_COLOR="$COLOR_LBLU"
					# Light Snow
					elif [ "${DATA_ARRAY[0]}" == "Light Snow" ]; then
						if [ "$DISPLAY_ENCODING" == "UTF8" ]; then
							DECORATION_STRING=".❄\"$DISPLAY_ESCAPE_SPACE\
$DISPLAY_ESCAPE_SPACE$DISPLAY_ESCAPE_SPACE"
						else
							DECORATION_STRING='.`"'"$DISPLAY_ESCAPE_SPACE\
$DISPLAY_ESCAPE_SPACE$DISPLAY_ESCAPE_SPACE"
						fi
						DECORATION_COLOR="$COLOR_WHIT"
					# Snow
					elif [ "${DATA_ARRAY[0]}" == "Snow" ]; then
						if [ "$DISPLAY_ENCODING" == "UTF8" ]; then
							DECORATION_STRING="❄✲❄❅❆❈❉.\"$DISPLAY_ESCAPE_SPACE"
						else
							DECORATION_STRING='"`.'"$DISPLAY_ESCAPE_SPACE"
						fi
						DECORATION_COLOR="$COLOR_WHIT"
					# ???
					else
						DECORATION_STRING="?$DISPLAY_ESCAPE_SPACE"
						DECORATION_COLOR="$COLOR_NORM"
					fi
					NEW_DRAW[1]=$DECORATION_COLOR$(center $(randomize\
						$DECORATION_STRING $(( ${#DATA_ARRAY[0]}+4 )))\
						$CUR_COLS)$COLOR_NORM
					NEW_DRAW[3]=$DECORATION_COLOR$(center $(randomize\
						$DECORATION_STRING $(( ${#DATA_ARRAY[0]}+4 )))\
						$CUR_COLS)$COLOR_NORM
					NEW_DRAW[1]=${NEW_DRAW[1]//$DISPLAY_ESCAPE_SPACE/ }
					NEW_DRAW[3]=${NEW_DRAW[3]//$DISPLAY_ESCAPE_SPACE/ }
					NEW_DRAW[2]=$DECORATION_COLOR$(center\
						"${DECORATION_STRING:0:1} ${DATA_ARRAY[0]} \
${DECORATION_STRING:0:1}" $CUR_COLS)$COLOR_NORM

					# Row 4 is blank

					# Row 5 shows the temperature
					NEW_DRAW[5]=${DATA_ARRAY[$((1+WEATHER_TEMPERATURE_OFFSET\
						))]}$WEATHER_DEGREE_SYMBOL$WEATHER_TEMPERATURE_UNITS
					if [ "${DATA_ARRAY[$((3+WEATHER_TEMPERATURE_OFFSET))]}" \
						!= '-' ]; then
						NEW_DRAW[5]=${NEW_DRAW[5]}"  (feels like "\
${DATA_ARRAY[3]}$WEATHER_DEGREE_SYMBOL")"
					fi
					NEW_DRAW[5]=$(center "${NEW_DRAW[5]}" $CUR_COLS)

					# Row 6 shows the humidity
					NEW_DRAW[6]=$(center "Humidity: ${DATA_ARRAY[5]}%"\
						$CUR_COLS)

					# Row 7 shows the wind
					if [ "$CUR_ROWS" -gt 9 ]; then
						if [ "${DATA_ARRAY[8]}" != '-' ]; then
							if [ "${DATA_ARRAY[9]}" != '-' ]; then
								NEW_DRAW[7]="Wind: ${DATA_ARRAY[8]} "\
${DATA_ARRAY[9]}"mph"
							else
								NEW_DRAW[7]="Wind: ${DATA_ARRAY[8]}"
							fi
						else
							if [ "${DATA_ARRAY[9]}" != '-' ]; then
								NEW_DRAW[7]="Wind: ${DATA_ARRAY[9]}mph"
							else
								NEW_DRAW[7]="Wind: - unavailable -"
							fi
						fi
						NEW_DRAW[7]=$(center "${NEW_DRAW[7]}" $CUR_COLS)
					fi

					# Row 8 shows visibility
					if [ "$CUR_ROWS" -gt 10 ]; then
						NEW_DRAW[8]=$(center "Visibility: ${DATA_ARRAY[10]}mi"\
							$CUR_COLS)
					fi

					# Row N-2 shows the name of the observatory
					if [ "$CUR_ROWS" -gt 11 ]; then
						NEW_DRAW[$((CUR_ROWS-2))]=$(center\
							"From: ${DATA_ARRAY[11]}" $CUR_COLS)
					fi

					# Row N-1 shows the update timestamp
					if [ "$CUR_ROWS" -gt 7 ]; then
						NEW_DRAW[$((CUR_ROWS-1))]=$(center "Updated: $(date -d\
							"${DATA_ARRAY[6]}" "+%I:%M%p") | ${DATA_ARRAY[7]}"\
							$CUR_COLS)
					fi

				# Largest heights (20+): the full Monty!
				else
					# Rows 0-1 have a heading
					if [ "$DISPLAY_ENCODING" == "UTF8" ]; then
						NEW_DRAW[0]="$COLOR_GRAY Weather $COLOR_NORM│"
						NEW_DRAW[1]="─────────┘"
					else
						NEW_DRAW[0]="$COLOR_GRAY Weather $COLOR_NORM|"
						NEW_DRAW[1]="---------+"
					fi

					# Row 2 shows the weather status and
					# Rows 3-9 Show a large-size decorated temperature read-out
					DECORATION_STRING=" "
					DECORATION_COLOR="$COLOR_NORM"
					DECORATION_COLOR_BG="$COLOR_BG_NORM"
					# Fair
					if [ "${DATA_ARRAY[0]}" == "Fair" ]; then
						DECORATION_STRING="-$DISPLAY_ESCAPE_SPACE"
						DECORATION_COLOR="$COLOR_YELO"
						DECORATION_COLOR_BG="$COLOR_BG_YELO"
					# A Few Clouds
					elif [ "${DATA_ARRAY[0]}" == "A Few Clouds" ]; then
						if [ "$DISPLAY_ENCODING" == "UTF8" ]; then
							DECORATION_STRING="~☁$DISPLAY_ESCAPE_SPACE\
$DISPLAY_ESCAPE_SPACE$DISPLAY_ESCAPE_SPACE"
						else
							DECORATION_STRING="~3$DISPLAY_ESCAPE_SPACE\
$DISPLAY_ESCAPE_SPACE$DISPLAY_ESCAPE_SPACE"
						fi
						DECORATION_COLOR="$COLOR_YELO"
						DECORATION_COLOR_BG="$COLOR_BG_YELO"
					# Partly Cloudy
					elif [ "${DATA_ARRAY[0]}" == "Partly Cloudy" ]; then
						if [ "$DISPLAY_ENCODING" == "UTF8" ]; then
							DECORATION_STRING="☁~$DISPLAY_ESCAPE_SPACE\
$DISPLAY_ESCAPE_SPACE"
						else
							DECORATION_STRING="3~$DISPLAY_ESCAPE_SPACE\
$DISPLAY_ESCAPE_SPACE"
						fi
						DECORATION_COLOR="$COLOR_WHIT"
						DECORATION_COLOR_BG="$COLOR_BG_WHIT"
					# Mostly Cloudy
					elif [ "${DATA_ARRAY[0]}" == "Mostly Cloudy" ]; then
						if [ "$DISPLAY_ENCODING" == "UTF8" ]; then
							DECORATION_STRING="☁~$DISPLAY_ESCAPE_SPACE"
						else
							DECORATION_STRING="3~$DISPLAY_ESCAPE_SPACE"
						fi
						DECORATION_COLOR="$COLOR_GRAY"
						DECORATION_COLOR_BG="$COLOR_BG_GRAY"
					# Overcast with Haze
					elif [ "${DATA_ARRAY[0]}" == "Overcast with Haze" ]; then
						if [ "$DISPLAY_ENCODING" == "UTF8" ]; then
							DECORATION_STRING="☁☁ᢆᢆ░3~"
						else
							DECORATION_STRING="333~~"
						fi
						DECORATION_COLOR="$COLOR_GRAY"
						DECORATION_COLOR_BG="$COLOR_BG_GRAY"
					# Overcast
					elif [ "${DATA_ARRAY[0]}" == "Overcast" ]; then
						if [ "$DISPLAY_ENCODING" == "UTF8" ]; then
							DECORATION_STRING="☁☁☁3~"
						else
							DECORATION_STRING="333~~"
						fi
						DECORATION_COLOR="$COLOR_GRAY"
						DECORATION_COLOR_BG="$COLOR_BG_GRAY"
					# Rain
					elif [ "${DATA_ARRAY[0]}" == "Rain" ]; then
						DECORATION_STRING='````'"'''\\\\\|"
						DECORATION_COLOR="$COLOR_BLUE"
						DECORATION_COLOR_BG="$COLOR_BG_BLUE"
					# Light Freezing Rain Fog/Mist
					elif [ "${DATA_ARRAY[0]}" ==\
						"Light Freezing Rain Fog/Mist" ]; then
						if [ "$DISPLAY_ENCODING" == "UTF8" ]; then
							DECORATION_STRING="\`\`\\\\☁~   "
						else
							DECORATION_STRING="\`\`\\\\3~   "
						fi
						DECORATION_COLOR="$COLOR_LBLU"
						DECORATION_COLOR_BG="$COLOR_BG_LBLU"
					# Light Snow
					elif [ "${DATA_ARRAY[0]}" == "Light Snow" ]; then
						if [ "$DISPLAY_ENCODING" == "UTF8" ]; then
							DECORATION_STRING=".❄\"$DISPLAY_ESCAPE_SPACE\
$DISPLAY_ESCAPE_SPACE$DISPLAY_ESCAPE_SPACE"
						else
							DECORATION_STRING='.`"'"$DISPLAY_ESCAPE_SPACE\
$DISPLAY_ESCAPE_SPACE$DISPLAY_ESCAPE_SPACE"
						fi
						DECORATION_COLOR="$COLOR_WHIT"
						DECORATION_COLOR_BG="$COLOR_BG_WHIT"
					# Snow
					elif [ "${DATA_ARRAY[0]}" == "Snow" ]; then
						if [ "$DISPLAY_ENCODING" == "UTF8" ]; then
							DECORATION_STRING="❄✲❄❅❆❈❉.\"$DISPLAY_ESCAPE_SPACE"
						else
							DECORATION_STRING='"`.'"$DISPLAY_ESCAPE_SPACE"
						fi
						DECORATION_COLOR="$COLOR_WHIT"
						DECORATION_COLOR_BG="$COLOR_BG_WHIT"
					# ???
					else
						DECORATION_STRING="?$DISPLAY_ESCAPE_SPACE"
						DECORATION_COLOR="$COLOR_NORM"
						DECORATION_COLOR_BG="$COLOR_BG_NORM"
					fi
					LARGE_3=""
					LARGE_4=""
					LARGE_5=""
					LARGE_6=""
					LARGE_7=""
					LARGE_8=""
					LARGE_9=""
					TEMP=${DATA_ARRAY[$((1 + WEATHER_TEMPERATURE_OFFSET\
						))]}$WEATHER_DEGREE_SYMBOL$WEATHER_TEMPERATURE_UNITS
					for (( i=0; i<${#TEMP}; i++ )); do
						CHAR=${TEMP:$i:1}
						LARGE_3=$LARGE_3$(randomize $DECORATION_STRING 6)
						LARGE_4=$LARGE_4" "${LARGE_READ_OUT["$CHAR",0]}
						LARGE_5=$LARGE_5" "${LARGE_READ_OUT["$CHAR",1]}
						LARGE_6=$LARGE_6" "${LARGE_READ_OUT["$CHAR",2]}
						LARGE_7=$LARGE_7" "${LARGE_READ_OUT["$CHAR",3]}
						LARGE_8=$LARGE_8" "${LARGE_READ_OUT["$CHAR",4]}
						LARGE_9=$LARGE_9$(randomize $DECORATION_STRING 6)
					done
					LARGE_3=$(center $(randomize $DECORATION_STRING 2)\
$LARGE_3$(randomize $DECORATION_STRING 2) $CUR_COLS)
					LARGE_4=$(center "$(randomize $DECORATION_STRING \
1) $LARGE_4 $(randomize $DECORATION_STRING 1)" $CUR_COLS)
					LARGE_5=$(center "$(randomize $DECORATION_STRING \
1) $LARGE_5 $(randomize $DECORATION_STRING 1)" $CUR_COLS)
					LARGE_6=$(center "$(randomize $DECORATION_STRING \
1) $LARGE_6 $(randomize $DECORATION_STRING 1)" $CUR_COLS)
					LARGE_7=$(center "$(randomize $DECORATION_STRING \
1) $LARGE_7 $(randomize $DECORATION_STRING 1)" $CUR_COLS)
					LARGE_8=$(center "$(randomize $DECORATION_STRING \
1) $LARGE_8 $(randomize $DECORATION_STRING 1)" $CUR_COLS)
					LARGE_9=$(center $(randomize $DECORATION_STRING 2)\
$LARGE_9$(randomize $DECORATION_STRING 2) $CUR_COLS)
					LARGE_3=${LARGE_3//"$DISPLAY_ESCAPE_SPACE"/ }
					LARGE_4=${LARGE_4//"$DISPLAY_ESCAPE_SPACE"/ }
					LARGE_5=${LARGE_5//"$DISPLAY_ESCAPE_SPACE"/ }
					LARGE_6=${LARGE_6//"$DISPLAY_ESCAPE_SPACE"/ }
					LARGE_7=${LARGE_7//"$DISPLAY_ESCAPE_SPACE"/ }
					LARGE_8=${LARGE_8//"$DISPLAY_ESCAPE_SPACE"/ }
					LARGE_9=${LARGE_9//"$DISPLAY_ESCAPE_SPACE"/ }
					LARGE_4=${LARGE_4//"X"/$DECORATION_COLOR_BG $COLOR_BG_NORM}
					LARGE_5=${LARGE_5//"X"/$DECORATION_COLOR_BG $COLOR_BG_NORM}
					LARGE_6=${LARGE_6//"X"/$DECORATION_COLOR_BG $COLOR_BG_NORM}
					LARGE_7=${LARGE_7//"X"/$DECORATION_COLOR_BG $COLOR_BG_NORM}
					LARGE_8=${LARGE_8//"X"/$DECORATION_COLOR_BG $COLOR_BG_NORM}
					NEW_DRAW[2]=$DECORATION_COLOR$(center "${DATA_ARRAY[0]}"\
						$CUR_COLS)$COLOR_NORM
					NEW_DRAW[3]=$DECORATION_COLOR$LARGE_3$COLOR_NORM
					NEW_DRAW[4]=$DECORATION_COLOR$LARGE_4$COLOR_NORM
					NEW_DRAW[5]=$DECORATION_COLOR$LARGE_5$COLOR_NORM
					NEW_DRAW[6]=$DECORATION_COLOR$LARGE_6$COLOR_NORM
					NEW_DRAW[7]=$DECORATION_COLOR$LARGE_7$COLOR_NORM
					NEW_DRAW[8]=$DECORATION_COLOR$LARGE_8$COLOR_NORM
					NEW_DRAW[9]=$DECORATION_COLOR$LARGE_9$COLOR_NORM

					# Row 10 shows the effective temperature
					if [ "${DATA_ARRAY[$((3+WEATHER_TEMPERATURE_OFFSET))]}" \
						!= '-' ]; then
						NEW_DRAW[10]=$(center\
						"(feels like ${DATA_ARRAY[3]}$WEATHER_DEGREE_SYMBOL)"\
						$CUR_COLS)
					else
						NEW_DRAW[10]=""
					fi

					# Row 11 is blank

					# Row 12 shows the humidity
					NEW_DRAW[12]=$(center "Humidity: ${DATA_ARRAY[5]}%"\
						$CUR_COLS)

					# Row 13 shows the wind
					if [ "${DATA_ARRAY[8]}" != '-' ]; then
						if [ "${DATA_ARRAY[9]}" != '-' ]; then
							NEW_DRAW[13]="Wind: ${DATA_ARRAY[8]} "\
${DATA_ARRAY[9]}"mph"
						else
							NEW_DRAW[13]="Wind: ${DATA_ARRAY[8]}"
						fi
					else
						if [ "${DATA_ARRAY[9]}" != '-' ]; then
							NEW_DRAW[13]="Wind: ${DATA_ARRAY[9]}mph"
						else
							NEW_DRAW[13]="Wind: - unavailable -"
						fi
					fi
					NEW_DRAW[13]=$(center "${NEW_DRAW[13]}" $CUR_COLS)

					# Row 14 shows visibility
					NEW_DRAW[14]=$(center "Visibility: ${DATA_ARRAY[10]}mi"\
						$CUR_COLS)

					# Rows 15 and 16 are blank

					# Rows 17-(N-3) have a weather graphic
					if [ "$CUR_ROWS" -gt "20" ]; then
						for i in `seq 17 $((CUR_ROWS-4))`; do
							LINE_ESCAPED=$(center "$(randomize "\
$DECORATION_STRING$DISPLAY_ESCAPE_SPACE$DISPLAY_ESCAPE_SPACE\
$DISPLAY_ESCAPE_SPACE$DISPLAY_ESCAPE_SPACE" $((CUR_COLS/2)))" $CUR_COLS)
							NEW_DRAW[$i]=$DECORATION_COLOR\
${LINE_ESCAPED//"$DISPLAY_ESCAPE_SPACE"/ }$COLOR_NORM
						done
					fi

					# Row N-2 shows the name of the observatory
					NEW_DRAW[$((CUR_ROWS-2))]=$(center\
						"From: ${DATA_ARRAY[11]}" $CUR_COLS)

					# Row N-1 shows the update timestamp
					NEW_DRAW[$((CUR_ROWS-1))]=$(center "Updated: $(date -d\
						"${DATA_ARRAY[6]}" "+%I:%M%p") | ${DATA_ARRAY[7]}"\
						$CUR_COLS)
				fi
			fi
		fi

		# --- System Stats ----------------------------------
		if [ "$CUR_SECT" == 'Y' ]; then
			# If the data is old, download new data, otherwise use the old data
			if [ "$DATA_FRESH" = 0 ]; then
				NEW_DATA="---"
				DATA=$NEW_DATA
			else
				DATA=$OLD_DATA
			fi

			# If the drawing is old, redo it
			if [ "$SIZE_FRESH" = 0 ]; then
				# Create an empty array of rows
				NEW_DRAW=($DISPLAY_ESCAPE_SPACE$(printf\
					" $DISPLAY_ESCAPE_SPACE%.0s" $(seq 2 $CUR_ROWS)))
				for i in `seq 0 $((CUR_ROWS-1))`; do NEW_DRAW[$i]=" "; done

				# Expand the data into an array, handling string escapes
				# Smallest heights (3-7): just show most relevant info
				if [ "$CUR_ROWS" -lt 8 ]; then
					NEW_DRAW[0]=" "

				# Medium heights (8-19): add some formatting
				elif [ "$CUR_ROWS" -lt 20 ]; then
					# Row 0 has a heading
					NEW_DRAW[0]=" $COLOR_GRAY["$COLOR_ULINE"System Stats\
$COLOR_ULINE_OFF]$COLOR_NORM"

				# Largest heights (20+): the full Monty!
				else
					# Rows 0-1 have a heading
					if [ "$DISPLAY_ENCODING" == "UTF8" ]; then
						NEW_DRAW[0]="$COLOR_GRAY System Stats $COLOR_NORM│"
						NEW_DRAW[1]="──────────────┘"
					else
						NEW_DRAW[0]="$COLOR_GRAY System Stats $COLOR_NORM|"
						NEW_DRAW[1]="--------------+"
					fi
				fi
			fi
		fi

		# Get the correct data and date
		if [ "$DATA_FRESH" = 0 ]; then
			if [ "$DBG" = 1 ]; then msg "New Data"; fi
			DATA=$NEW_DATA
			DATE=$NEW_DATE
		else
			if [ "$DBG" = 1 ]; then msg "Old Data"; fi
			DATA=$OLD_DATA
			DATE=$OLD_DATE
		fi

		# Get the correct size and drawing
		if [ "$SIZE_FRESH" = 0 ]; then
			if [ "$DBG" = 1 ]; then msg "New Drawing"; fi
			SIZE=$NEW_SIZE
			DRAW=("${NEW_DRAW[@]}")
		else
			if [ "$DBG" = 1 ]; then msg "Old Drawing"; fi
			SIZE=$OLD_SIZE
			DRAW=("${OLD_DRAW[@]}")
		fi

		# If anything has changed, write to the dash file and print it
		if [ "$((DATA_FRESH+SIZE_FRESH+STARTED))" -lt 3 ]; then
			# Print data to file
			echo "$DATE" > "$DASH_ROOT/$CUR_SECT"".dash"
			echo "$DATA" >> "$DASH_ROOT/$CUR_SECT"".dash"
			echo "$SIZE" >> "$DASH_ROOT/$CUR_SECT"".dash"
			printf '%s\n' "${DRAW[@]}"  >> "$DASH_ROOT/$CUR_SECT"".dash"

			if [ "$DBG" = 0 ]; then
				# Print top border as needed
				if [ "$BORDER_TOP" = 1 ]; then
					tput cup $ROWS_PROCESSED $COLS_PROCESSED
					if [ "$CUR_X" -gt 0 ]; then
						if [[ "$PREV_SECT" != "_" ]]; then
							echo -n $DISPLAY_SEPARATOR_C;
						else
							echo -n $DISPLAY_SEPARATOR_CA;
						fi
					fi
					if [ "$DISPLAY_SEPARATOR_H" == "-" ]; then
						echo "$(head -c "$CUR_COLS" < "/dev/zero"|tr '\0' '-')"
					else
						printf "$DISPLAY_SEPARATOR_H%.0s" $(seq 1 $CUR_COLS)
					fi
				fi

				# Print left border and content
				for i in `seq 0 $((CUR_ROWS-1))`; do
					# Clear the row first
					tput cup $((ROWS_PROCESSED+BORDER_TOP+i))\
						$((COLS_PROCESSED+BORDER_LEFT))
					printf "%*s" $CUR_COLS " "
					# Reset the cursor and print content
					tput cup $((ROWS_PROCESSED+BORDER_TOP+i)) $COLS_PROCESSED
					if [ "$BORDER_LEFT" = 1 ]; then
						if [[ "$PREV_SECT" != "_" ]]; then
							echo -n "$DISPLAY_SEPARATOR_V";
						fi
					fi
					echo -n "${DRAW[$i]}"
				done
			fi
		fi

		# Done with one section drawing
		if [ "$CUR_X" -eq "$((SECTS_X-1))" ]; then
			COLS_PROCESSED=0
			ROWS_PROCESSED=$((ROWS_PROCESSED+CUR_ROWS+BORDER_TOP))
		else
			COLS_PROCESSED=$((COLS_PROCESSED+CUR_COLS+BORDER_LEFT))
		fi
		((++SECTS_PROCESSED))
		PREV_SECT=$CUR_SECT
	done

	# Wait until the next refresh
	STARTED=1
	TMP="nop"
	read -t $REFRESH_RATE_SECONDS TMP
	if [ "$TMP" == "r" ]; then STARTED=0; fi
}

# Loop the section processing code ad infinitum (exit with CTRL+c)
while true; do
	render_sections
done
